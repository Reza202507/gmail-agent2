import os
import json
import base64
from datetime import datetime
from openai import OpenAI
from dotenv import load_dotenv
from email.mime.text import MIMEText

# Load environment variables
load_dotenv()

# Initialize OpenAI client
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# Signature appended to every auto-reply
AGENT_SIGNATURE = (
    "\n\n‚Äî\nReplied autonomously by Reza Zigheimat‚Äôs AI Agent (Dovey). "
    "Still under development, like most humans üòú."
)

# Path to the log file for sent replies
LOG_PATH = os.path.join(os.path.dirname(__file__), '..', 'sent_replies.json')


def send_auto_reply(service, thread_id, sender, subject, body, summary, tags):
    """
    Generate and send an automated email reply via Gmail API, then log the reply.

    Args:
        service: Authorized Gmail API service instance.
        thread_id: ID of the Gmail thread to reply to.
        sender: Email address of the original sender.
        subject: Subject line of the original email.
        body: Full body text of the original email.
        summary: Brief summary generated by the summariser.
        tags: List of tags generated by the tagger.

    Returns:
        The log entry dictionary for the sent reply.
    """
    # Compose system and user prompts for GPT
    system_prompt = (
        "You are Reza Zigheimat‚Äôs AI Email Agent (Dovey). "
        "Write a concise, friendly, professional reply in first person, under 100 words."
    )
    user_prompt = (
        f"Email received from: {sender}\n"
        f"Subject: {subject}\n\n"
        f"Body:\n{body}\n\n"
        f"Summary:\n{summary}\n\n"
        f"Tags: {tags}\n\n"
        "Please compose the reply without repeating the original text."
    )

    # Generate reply text via OpenAI
    try:
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.3,
            max_tokens=300
        )
        reply_text = response.choices[0].message.content.strip()
    except Exception as e:
        print(f"‚ö†Ô∏è GPT Error: {e}")
        reply_text = "Hi, thank you for your email. I'll get back to you shortly."

    # Append signature
    final_message = reply_text + AGENT_SIGNATURE

    # Create MIME message and encode
    mime_msg = MIMEText(final_message)
    mime_msg['to'] = sender
    mime_msg['subject'] = f"Re: {subject}"
    mime_msg['in-reply-to'] = thread_id
    raw = base64.urlsafe_b64encode(mime_msg.as_bytes()).decode()

    # Send the email
    try:
        service.users().messages().send(userId='me', body={'raw': raw}).execute()
        print(f"‚úÖ Auto-reply sent to: {sender}")
    except Exception as e:
        print(f"‚ö†Ô∏è Failed to send email to {sender}: {e}")

    # Log the sent reply for deduplication and analytics
    log_entry = {
        "thread_id": thread_id,
        "to": sender,
        "subject": subject,
        "reply": reply_text,
        "tags": tags,
        "summary": summary,
        "timestamp": datetime.utcnow().isoformat()
    }
    try:
        if os.path.exists(LOG_PATH):
            with open(LOG_PATH, 'r', encoding='utf-8') as f:
                log_data = json.load(f)
        else:
            log_data = []
        log_data.append(log_entry)
        with open(LOG_PATH, 'w', encoding='utf-8') as f:
            json.dump(log_data, f, indent=2)
    except Exception as e:
        print(f"‚ö†Ô∏è Failed to write log entry: {e}")

    return log_entry
